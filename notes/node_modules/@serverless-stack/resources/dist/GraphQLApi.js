import { App } from "./App.js";
import spawn from "cross-spawn";
import { Api } from "./Api.js";
/**
 * The `GraphQLApi` construct is a higher level CDK construct that makes it easy to create GraphQL servers with AWS Lambda. It provides a simple way to define the GraphQL handler route in your API. And allows you to configure the specific Lambda function if necessary. It also allows you to configure authorization, custom domains, etc.
 *
 * The `GraphQLApi` construct internally extends the [`Api`](Api) construct.
 *
 * @example
 * ### Using the minimal config
 *
 * ```js
 * import { GraphQLApi } from "@serverless-stack/resources";
 *
 * new GraphQLApi(stack, "Api", {
 *   server: "src/graphql.handler",
 * });
 * ```
 */
export class GraphQLApi extends Api {
    constructor(scope, id, props) {
        if ("routes" in props || !props.server) {
            throw new Error(`Please use the "server" option instead of the "routes" to configure the handler for the "${id}" GraphQLApi`);
        }
        if (props.codegen) {
            const app = App.of(scope);
            if (!app.local) {
                const result = spawn.sync("npx", ["graphql-codegen", "-c", props.codegen], {
                    stdio: "inherit",
                });
                if (result.status !== 0) {
                    throw new Error(`Failed to generate the schema for the "${id}" GraphQLApi`);
                }
            }
        }
        const rootPath = props.rootPath || "/";
        super(scope, id, {
            ...props,
            routes: {
                [`GET ${rootPath}`]: { function: props.server },
                [`POST ${rootPath}`]: { function: props.server },
            },
        });
        this.rootPath = rootPath;
        this.codegen = props.codegen;
    }
    get serverFunction() {
        const serverFn = this.getFunction(`GET ${this.rootPath}`);
        // This should never happen
        if (!serverFn) {
            throw new Error(`Failed to get "serverFunction" in the "${this.node.id}" GraphQLApi`);
        }
        return serverFn;
    }
    // Note: We want to create 1 Lambda handling both the GET and POST request.
    //       This design is based on this discussion on GitHub
    //       https://github.com/serverless-stack/sst/issues/601
    // Also Note: We cannot use the "ANY /" route because if authorization
    //            were provided, the OPTIONS route will be protected. This
    //            causes CORS to fail.
    // Solution: We will override the createFunctionIntegration() function, and
    //           it will re-use the same Route Integration for all routes.
    createFunctionIntegration(scope, routeKey, routeProps, postfixName) {
        if (!this.lambdaIntegration) {
            this.lambdaIntegration = super.createFunctionIntegration(scope, routeKey, routeProps, postfixName);
        }
        return this.lambdaIntegration;
    }
    getConstructMetadata() {
        const parent = super.getConstructMetadata();
        return {
            ...parent,
            data: {
                ...parent.data,
                graphql: true,
                codegen: this.codegen,
            },
        };
    }
}
