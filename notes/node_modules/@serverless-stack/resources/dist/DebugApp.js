import * as cdk from "aws-cdk-lib";
import { isStackConstruct, isSSTDebugStack } from "./Construct.js";
/**
 * The DebugApp construct is used internally by SST to
 * - Deploy the [`DebugStack`](DebugStack.md). It contains the resources that powers [Live Lambda Development](/live-lambda-development.md).
 * - Automatically prefix the debug stack name with the stage and app name.
 *
 * It extends [`cdk.App`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.App.html). It's made available as the `app` in the `debugApp()` callback in the `stacks/index.js` of your SST app.
 *
 * ```js
 * export function debugApp(app) {
 *   new sst.DebugStack(app, "debug-stack");
 * }
 * ```
 *
 * Since it is initialized internally, the props that are passed to `DebugApp` cannot be changed.
 *
 * @example
 */
export class DebugApp extends cdk.App {
    /**
     * @internal
     */
    constructor(deployProps) {
        super();
        this.name = deployProps.name;
        this.stage = deployProps.stage;
        this.region = deployProps.region;
        this.account = process.env.CDK_DEFAULT_ACCOUNT || "my-account";
    }
    synth(options = {}) {
        // Check app has stack
        const stacks = this.node.children.filter((child) => isSSTDebugStack(child));
        if (stacks.length > 1) {
            console.error(`Error: You can only create 1 DebugStack inside the "debugApp()" callback.\n`);
            process.exit(1);
        }
        if (stacks.length === 0) {
            console.error(`Error: The "debugApp()" callback is not creating a DebugStack.\n`);
            process.exit(1);
        }
        for (const child of this.node.children) {
            if (isStackConstruct(child)) {
                // Stack names need to be parameterized with the stage name
                if (!child.stackName.startsWith(`${this.stage}-`) &&
                    !child.stackName.endsWith(`-${this.stage}`) &&
                    child.stackName.indexOf(`-${this.stage}-`) === -1) {
                    console.error(`Error: Stack "${child.stackName}" is not parameterized with the stage name. The stack name needs to either start with "$stage-", end in "-$stage", or contain the stage name "-$stage-".\n`);
                    process.exit(1);
                }
            }
        }
        return super.synth(options);
    }
    /**
     * Use this method to prefix resource names in your stacks to make sure they don't thrash when deployed to different stages in the same AWS account. This method will prefix a given resource name with the stage and app name. Using the format `${stage}-${name}-${logicalName}`.
     */
    logicalPrefixedName(logicalName) {
        return `${this.stage}-${this.name}-${logicalName}`;
    }
}
