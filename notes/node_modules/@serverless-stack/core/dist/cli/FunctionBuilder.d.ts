import { InterpreterFrom, StateFrom } from "xstate";
import chokidar from "chokidar";
import { Handler } from "../runtime/handler/index.js";
import { EventDelegate } from "../events.js";
import { Issue } from "../runtime/handler/definition.js";
declare type Context = {
    funcs: Record<string, InterpreterFrom<typeof funcMachine>>;
    chokidar?: chokidar.FSWatcher;
};
declare type Opts = {
    root: string;
    checks: Record<string, boolean>;
};
export declare function useFunctionBuilder(opts: Opts): {
    ctx: Context;
    reload: () => Record<string, import("xstate").Interpreter<FuncContext, any, FuncEvents, {
        value: any;
        context: FuncContext;
    }>>;
    send: (id: string, event: FuncEvents) => import("xstate").State<FuncContext, FuncEvents, any, {
        value: any;
        context: FuncContext;
    }>;
    broadcast: (event: FuncEvents) => void;
    onTransition: EventDelegate<{
        state: StateFrom<typeof funcMachine>;
        actor: InterpreterFrom<typeof funcMachine>;
    }>;
    onChange: EventDelegate<{
        ctx: StateFrom<typeof funcMachine>["context"];
        actor: InterpreterFrom<typeof funcMachine>;
    }>;
};
declare type FileChangeEvent = {
    type: "FILE_CHANGE";
    file: string;
};
declare type InvokeEvent = {
    type: "INVOKE";
};
declare type FuncEvents = FileChangeEvent | InvokeEvent;
declare type FuncContext = {
    info: Handler.Opts;
    instructions: Handler.Instructions;
    checks: Opts["checks"];
    issues: Record<string, Issue>;
    buildStart?: number;
    warm: boolean;
    dirty: boolean;
};
declare const funcMachine: import("xstate").StateMachine<FuncContext, any, FuncEvents, {
    value: any;
    context: FuncContext;
}, import("xstate").ActionObject<FuncContext, FuncEvents>>;
export {};
