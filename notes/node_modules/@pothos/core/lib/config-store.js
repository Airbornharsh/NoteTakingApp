"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    get: ()=>ConfigStore,
    enumerable: true
});
const _graphql = require("graphql");
const _ = require(".");
class ConfigStore {
    hasConfig(typeParam) {
        if (typeof typeParam === 'string') {
            return this.typeConfigs.has(typeParam);
        }
        return this.refsToName.has(typeParam);
    }
    addInterfaces(typeName, interfaces) {
        if (typeof interfaces === 'function' && this.pending) {
            if (!this.pendingInterfaces.has(typeName)) {
                this.pendingInterfaces.set(typeName, [
                    interfaces
                ]);
            } else {
                this.pendingInterfaces.get(typeName).push(interfaces);
            }
        } else {
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== 'Object' && typeConfig.graphqlKind !== 'Interface' || typeConfig.kind === 'Query' || typeConfig.kind === 'Mutation' || typeConfig.kind === 'Subscription') {
                throw new Error(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.interfaces = [
                ...typeConfig.interfaces,
                ...typeof interfaces === 'function' ? interfaces() : interfaces, 
            ];
        }
    }
    addFieldRef(ref, // We need to be able to resolve the types kind before configuring the field
    typeParam, args, getConfig) {
        if (this.fieldRefs.has(ref)) {
            throw new Error(`FieldRef ${String(ref)} has already been added to config store`);
        }
        const typeRefOrName = Array.isArray(typeParam) ? typeParam[0] : typeParam;
        const argRefs = Object.keys(args).map((argName)=>{
            const argRef = args[argName];
            argRef.fieldName = argName;
            argRef.argFor = ref;
            return argRef;
        });
        const checkArgs = ()=>{
            for (const arg of argRefs){
                if (this.pendingFields.has(arg)) {
                    const unresolvedArgType = this.pendingFields.get(arg);
                    this.pendingFields.set(ref, unresolvedArgType);
                    this.onTypeConfig(unresolvedArgType, checkArgs);
                    return;
                }
            }
            this.pendingFields.delete(ref);
            this.fieldRefs.set(ref, getConfig);
        };
        if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof _.BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
            checkArgs();
        } else {
            this.pendingFields.set(ref, typeRefOrName);
            this.onTypeConfig(typeRefOrName, ()=>{
                checkArgs();
            });
        }
    }
    createFieldConfig(ref, name, typeConfig, parentField, kind) {
        if (!this.fieldRefs.has(ref)) {
            if (this.pendingFields.has(ref)) {
                throw new Error(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
            }
            throw new Error(`Missing definition for for ${String(ref)}`);
        }
        const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
        if (kind && config.graphqlKind !== kind) {
            throw new TypeError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
        }
        return config;
    }
    associateRefWithName(ref, name) {
        if (!this.typeConfigs.has(name)) {
            throw new Error(`${name} has not been implemented yet`);
        }
        this.refsToName.set(ref, name);
        if (this.pendingRefResolutions.has(ref)) {
            const cbs = this.pendingRefResolutions.get(ref);
            this.pendingRefResolutions.delete(ref);
            cbs.forEach((cb)=>void cb(this.typeConfigs.get(name)));
        }
    }
    addTypeConfig(config, ref) {
        const { name  } = config;
        if (this.typeConfigs.has(name)) {
            throw new Error(`Duplicate typename: Another type with name ${name} already exists.`);
        }
        this.typeConfigs.set(config.name, config);
        if (ref) {
            this.associateRefWithName(ref, name);
        }
        if (this.pendingRefResolutions.has(name)) {
            const cbs = this.pendingRefResolutions.get(name);
            this.pendingRefResolutions.delete(name);
            cbs.forEach((cb)=>void cb(config));
        }
    }
    getTypeConfig(ref, kind) {
        let config;
        if (typeof ref === 'string') {
            if (!this.typeConfigs.has(ref)) {
                throw new Error(`Type ${String(ref)} has not been implemented`);
            }
            config = this.typeConfigs.get(ref);
        } else if (this.refsToName.has(ref)) {
            config = this.typeConfigs.get(this.refsToName.get(ref));
        } else {
            throw new Error(`Ref ${String(ref)} has not been implemented`);
        }
        if (kind && config.graphqlKind !== kind) {
            throw new TypeError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
        }
        return config;
    }
    getInputTypeRef(ref) {
        if (ref instanceof _.BaseTypeRef) {
            if (ref.kind !== 'InputObject' && ref.kind !== 'Enum' && ref.kind !== 'Scalar') {
                throw new TypeError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === 'string') {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind !== 'InputObject' && config.graphqlKind !== 'Enum' && config.graphqlKind !== 'Scalar') {
                    throw new TypeError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
                }
                const newRef = new _.InputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    getOutputTypeRef(ref) {
        if (ref instanceof _.BaseTypeRef) {
            if (ref.kind === 'InputObject') {
                throw new TypeError(`Expected ${ref.name} to be an output type but got ${ref.name}`);
            }
            return ref;
        }
        if (typeof ref === 'string') {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind === 'InputObject') {
                    throw new TypeError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
                }
                const newRef = new _.OutputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    onTypeConfig(ref, cb) {
        if (!ref) {
            throw new Error(`${String(ref)} is not a valid type ref`);
        }
        if (this.refsToName.has(ref)) {
            cb(this.getTypeConfig(ref));
        } else if (typeof ref === 'string' && this.typeConfigs.has(ref)) {
            cb(this.typeConfigs.get(ref));
        } else if (!this.pending) {
            throw new Error(`Ref ${String(ref)} has not been implemented`);
        } else if (this.pendingRefResolutions.has(ref)) {
            this.pendingRefResolutions.get(ref).push(cb);
        } else {
            this.pendingRefResolutions.set(ref, [
                cb
            ]);
        }
    }
    onFieldUse(ref, cb) {
        if (!this.fieldRefCallbacks.has(ref)) {
            this.fieldRefCallbacks.set(ref, []);
        }
        this.fieldRefCallbacks.get(ref).push(cb);
        if (this.fieldRefsToConfigs.has(ref)) {
            this.fieldRefsToConfigs.get(ref).forEach((config)=>void cb(config));
        }
    }
    getFields(name, kind) {
        const typeConfig = this.getTypeConfig(name);
        if (!this.fields.has(name)) {
            this.fields.set(name, new Map());
        }
        const fields = this.fields.get(name);
        if (kind && typeConfig.graphqlKind !== kind) {
            throw new TypeError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
        }
        return fields;
    }
    prepareForBuild() {
        this.pending = false;
        const fns = this.addFieldFns;
        this.addFieldFns = [];
        fns.forEach((fn)=>void fn());
        if (this.pendingRefResolutions.size > 0) {
            throw new Error(`Missing implementations for some references (${[
                ...this.pendingRefResolutions.keys()
            ].map((ref)=>this.describeRef(ref)).join(', ')}).`);
        }
        for (const [typeName, interfacesFns] of this.pendingInterfaces){
            for (const fn of interfacesFns){
                this.addInterfaces(typeName, fn);
            }
        }
    }
    addFields(typeRef, fields) {
        if (this.pending) {
            this.addFieldFns.push(()=>void this.addFields(typeRef, fields));
        } else {
            this.onTypeConfig(typeRef, (config)=>{
                this.buildFields(typeRef, typeof fields === 'function' ? fields() : fields);
            });
        }
    }
    getImplementers(ref) {
        const typeConfig = this.getTypeConfig(ref, 'Interface');
        const implementers = [
            ...this.typeConfigs.values()
        ].filter((type)=>type.kind === 'Object' && type.interfaces.find((i)=>this.getTypeConfig(i).name === typeConfig.name));
        return implementers;
    }
    describeRef(ref) {
        var ref1;
        if (typeof ref === 'string') {
            return ref;
        }
        if (ref.toString !== ({}).toString) {
            return String(ref);
        }
        const usedBy = (ref1 = [
            ...this.pendingFields.entries()
        ].find(([fieldRef, typeRef])=>typeRef === ref)) === null || ref1 === void 0 ? void 0 : ref1[0];
        if (usedBy) {
            return `<unnamed ref or enum: used by ${usedBy}>`;
        }
        return `<unnamed ref or enum>`;
    }
    buildFields(typeRef, fields) {
        Object.keys(fields).forEach((fieldName)=>{
            const fieldRef = fields[fieldName];
            fieldRef.fieldName = fieldName;
            if (this.pendingFields.has(fieldRef)) {
                this.onTypeConfig(this.pendingFields.get(fieldRef), ()=>{
                    this.buildField(typeRef, fieldRef, fieldName);
                });
            } else {
                this.buildField(typeRef, fieldRef, fieldName);
            }
        });
    }
    buildField(typeRef, field, fieldName) {
        const typeConfig = this.getTypeConfig(typeRef);
        const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
        const existingFields = this.getFields(typeConfig.name);
        if (existingFields.has(fieldName)) {
            throw new Error(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
        }
        if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
            throw new TypeError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
        }
        existingFields.set(fieldName, fieldConfig);
        if (!this.fieldRefsToConfigs.has(field)) {
            this.fieldRefsToConfigs.set(field, []);
        }
        this.fieldRefsToConfigs.get(field).push(fieldConfig);
        if (this.fieldRefCallbacks.has(field)) {
            this.fieldRefCallbacks.get(field).forEach((cb)=>void cb(fieldConfig));
        }
    }
    constructor(){
        this.typeConfigs = new Map();
        this.fieldRefs = new WeakMap();
        this.fields = new Map();
        this.addFieldFns = [];
        this.refsToName = new Map();
        this.scalarsToRefs = new Map();
        this.fieldRefsToConfigs = new Map();
        this.pendingFields = new Map();
        this.pendingInterfaces = new Map();
        this.pendingRefResolutions = new Map();
        this.fieldRefCallbacks = new Map();
        this.pending = true;
        const scalars = [
            _graphql.GraphQLID,
            _graphql.GraphQLInt,
            _graphql.GraphQLFloat,
            _graphql.GraphQLString,
            _graphql.GraphQLBoolean, 
        ];
        scalars.forEach((scalar)=>{
            const ref = new _.BuiltinScalarRef(scalar);
            this.scalarsToRefs.set(scalar.name, ref);
            this.refsToName.set(ref, scalar.name);
        });
    }
}

//# sourceMappingURL=config-store.js.map