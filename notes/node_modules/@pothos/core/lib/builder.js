"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    get: ()=>SchemaBuilder,
    enumerable: true
});
const _graphql = require("graphql");
const _buildCache = _interopRequireDefault(require("./build-cache"));
const _configStore = _interopRequireDefault(require("./config-store"));
const _utils = require("./utils");
const _ = require(".");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class SchemaBuilder {
    static registerPlugin(name, plugin) {
        if (!this.allowPluginReRegistration && this.plugins[name]) {
            throw new Error(`Received multiple implementations for plugin ${name}`);
        }
        this.plugins[name] = plugin;
    }
    objectType(param, options, fields) {
        (0, _utils.verifyRef)(param);
        (0, _utils.verifyInterfaces)(options.interfaces);
        var _name;
        const name = typeof param === 'string' ? param : (_name = options.name) !== null && _name !== void 0 ? _name : param.name;
        if (name === 'Query' || name === 'Mutation' || name === 'Subscription') {
            throw new Error(`Invalid object name ${name} use .create${name}Type() instead`);
        }
        const ref = param instanceof _.BaseTypeRef ? param : new _.ObjectRef(name);
        const config = {
            kind: 'Object',
            graphqlKind: 'Object',
            name,
            interfaces: [],
            description: options.description,
            extensions: options.extensions,
            isTypeOf: options.isTypeOf,
            pothosOptions: options
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(name, options.interfaces);
        }
        if (typeof param === 'function') {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, ()=>fields(new _.ObjectFieldBuilder(name, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, ()=>{
                const t = new _.ObjectFieldBuilder(name, this);
                return options.fields(t);
            });
        }
        return ref;
    }
    objectFields(ref, fields) {
        (0, _utils.verifyRef)(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>fields(new _.ObjectFieldBuilder(name, this)));
        });
    }
    objectField(ref, fieldName, field) {
        (0, _utils.verifyRef)(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>({
                    [fieldName]: field(new _.ObjectFieldBuilder(name, this))
                }));
        });
    }
    queryType(options, fields) {
        const config = {
            kind: 'Query',
            graphqlKind: 'Object',
            name: 'Query',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields('Query', ()=>fields(new _.QueryFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields('Query', ()=>options.fields(new _.QueryFieldBuilder(this)));
        }
    }
    queryFields(fields) {
        this.configStore.addFields('Query', ()=>fields(new _.QueryFieldBuilder(this)));
    }
    queryField(name, field) {
        this.configStore.addFields('Query', ()=>({
                [name]: field(new _.QueryFieldBuilder(this))
            }));
    }
    mutationType(options, fields) {
        const config = {
            kind: 'Mutation',
            graphqlKind: 'Object',
            name: 'Mutation',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields('Mutation', ()=>fields(new _.MutationFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields('Mutation', ()=>options.fields(new _.MutationFieldBuilder(this)));
        }
    }
    mutationFields(fields) {
        this.configStore.addFields('Mutation', ()=>fields(new _.MutationFieldBuilder(this)));
    }
    mutationField(name, field) {
        this.configStore.addFields('Mutation', ()=>({
                [name]: field(new _.MutationFieldBuilder(this))
            }));
    }
    subscriptionType(options, fields) {
        const config = {
            kind: 'Subscription',
            graphqlKind: 'Object',
            name: 'Subscription',
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields('Subscription', ()=>fields(new _.SubscriptionFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields('Subscription', ()=>options.fields(new _.SubscriptionFieldBuilder(this)));
        }
    }
    subscriptionFields(fields) {
        this.configStore.addFields('Subscription', ()=>fields(new _.SubscriptionFieldBuilder(this)));
    }
    subscriptionField(name, field) {
        this.configStore.addFields('Subscription', ()=>({
                [name]: field(new _.SubscriptionFieldBuilder(this))
            }));
    }
    args(fields) {
        return fields(new _.InputFieldBuilder(this, 'Arg', '[unknown]'));
    }
    interfaceType(param, options, fields) {
        (0, _utils.verifyRef)(param);
        (0, _utils.verifyInterfaces)(options.interfaces);
        var _name;
        const name = typeof param === 'string' ? param : (_name = options.name) !== null && _name !== void 0 ? _name : param.name;
        const ref = param instanceof _.BaseTypeRef ? param : new _.InterfaceRef(name);
        const typename = ref.name;
        const config = {
            kind: 'Interface',
            graphqlKind: 'Interface',
            name: typename,
            interfaces: [],
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions,
            resolveType: options.resolveType
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(typename, options.interfaces);
        }
        if (typeof param === 'function') {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, ()=>fields(new _.InterfaceFieldBuilder(typename, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, ()=>options.fields(new _.InterfaceFieldBuilder(typename, this)));
        }
        return ref;
    }
    interfaceFields(ref, fields) {
        (0, _utils.verifyRef)(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>fields(new _.InterfaceFieldBuilder(name, this)));
        });
    }
    interfaceField(ref, fieldName, field) {
        (0, _utils.verifyRef)(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>({
                    [fieldName]: field(new _.InterfaceFieldBuilder(name, this))
                }));
        });
    }
    unionType(name, options) {
        const ref = new _.UnionRef(name);
        options.types.forEach((type)=>{
            (0, _utils.verifyRef)(type);
        });
        const config = {
            kind: 'Union',
            graphqlKind: 'Union',
            name,
            types: options.types || [],
            description: options.description,
            resolveType: options.resolveType,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    enumType(param, options) {
        (0, _utils.verifyRef)(param);
        const name = typeof param === 'string' ? param : options.name;
        const ref = new _.EnumRef(name);
        const values = typeof param === 'object' ? (0, _utils.valuesFromEnum)(param) : (0, _utils.normalizeEnumValues)(options.values);
        const config = {
            kind: 'Enum',
            graphqlKind: 'Enum',
            name,
            values,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        if (typeof param !== 'string') {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            this.configStore.associateRefWithName(param, name);
        }
        return ref;
    }
    scalarType(name, options) {
        const ref = new _.ScalarRef(name);
        const config = {
            kind: 'Scalar',
            graphqlKind: 'Scalar',
            name,
            description: options.description,
            parseLiteral: options.parseLiteral,
            parseValue: options.parseValue,
            serialize: options.serialize,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    addScalarType(name, scalar, options) {
        const config = scalar.toConfig();
        return this.scalarType(name, {
            ...config,
            ...options,
            extensions: {
                ...config.extensions,
                ...options.extensions
            }
        });
    }
    inputType(param, options) {
        (0, _utils.verifyRef)(param);
        const name = typeof param === 'string' ? param : param.name;
        const ref = typeof param === 'string' ? new _.InputObjectRef(name) : param;
        const config = {
            kind: 'InputObject',
            graphqlKind: 'InputObject',
            name,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addFields(ref, ()=>options.fields(new _.InputFieldBuilder(this, 'InputObject', name)));
        return ref;
    }
    inputRef(name) {
        return new _.ImplementableInputObjectRef(this, name);
    }
    objectRef(name) {
        return new _.ImplementableObjectRef(this, name);
    }
    interfaceRef(name) {
        return new _.ImplementableInterfaceRef(this, name);
    }
    toSchema(options) {
        const { directives , extensions  } = options;
        const scalars = [
            _graphql.GraphQLID,
            _graphql.GraphQLInt,
            _graphql.GraphQLFloat,
            _graphql.GraphQLString,
            _graphql.GraphQLBoolean
        ];
        scalars.forEach((scalar)=>{
            if (!this.configStore.hasConfig(scalar.name)) {
                this.addScalarType(scalar.name, scalar, {});
            }
        });
        const buildCache = new _buildCache.default(this, options);
        buildCache.plugin.beforeBuild();
        buildCache.buildAll();
        const builtTypes = [
            ...buildCache.types.values()
        ];
        const schema = new _graphql.GraphQLSchema({
            query: buildCache.types.get('Query'),
            mutation: buildCache.types.get('Mutation'),
            subscription: buildCache.types.get('Subscription'),
            extensions,
            directives: directives,
            types: builtTypes
        });
        return (0, _graphql.lexicographicSortSchema)(buildCache.plugin.afterBuild(schema));
    }
    constructor(options){
        this.options = options;
        this.configStore = new _configStore.default();
        var _defaultFieldNullability;
        this.defaultFieldNullability = (_defaultFieldNullability = options.defaultFieldNullability) !== null && _defaultFieldNullability !== void 0 ? _defaultFieldNullability : false;
        var _defaultInputFieldRequiredness;
        this.defaultInputFieldRequiredness = (_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _defaultInputFieldRequiredness !== void 0 ? _defaultInputFieldRequiredness : false;
    }
}
SchemaBuilder.plugins = {};
SchemaBuilder.allowPluginReRegistration = false;

//# sourceMappingURL=builder.js.map