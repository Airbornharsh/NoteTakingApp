"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        get: all[name],
        enumerable: true
    });
}
_export(exports, {
    assertArray: ()=>assertArray,
    assertNever: ()=>assertNever,
    brandWithType: ()=>brandWithType,
    getTypeBrand: ()=>getTypeBrand,
    isThenable: ()=>isThenable,
    verifyInterfaces: ()=>verifyInterfaces,
    verifyRef: ()=>verifyRef
});
const _types = require("../types");
_exportStar(require("./context-cache"), exports);
_exportStar(require("./enums"), exports);
_exportStar(require("./input"), exports);
_exportStar(require("./params"), exports);
_exportStar(require("./sort-classes"), exports);
function _exportStar(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) Object.defineProperty(to, k, {
            enumerable: true,
            get: function() {
                return from[k];
            }
        });
    });
    return from;
}
function assertNever(value) {
    throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
    if (!Array.isArray(value)) {
        throw new TypeError('List resolvers must return arrays');
    }
    return true;
}
function isThenable(value) {
    return !!(value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function');
}
function verifyRef(ref) {
    if (ref === undefined) {
        throw new Error(`Received undefined as a type ref.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
    }
}
function verifyInterfaces(interfaces) {
    if (!interfaces || typeof interfaces === 'function') {
        return;
    }
    if (!Array.isArray(interfaces)) {
        throw new TypeError('interfaces must be an array or function');
    }
    for (const iface of interfaces){
        if (iface === undefined) {
            throw new Error(`Received undefined in list of interfaces.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
        }
    }
}
function brandWithType(val, type) {
    if (typeof val !== 'object' || val === null) {
        return;
    }
    Object.defineProperty(val, _types.typeBrandKey, {
        enumerable: false,
        value: type
    });
}
function getTypeBrand(val) {
    if (typeof val === 'object' && val !== null && _types.typeBrandKey in val) {
        return val[_types.typeBrandKey];
    }
    return null;
}

//# sourceMappingURL=index.js.map