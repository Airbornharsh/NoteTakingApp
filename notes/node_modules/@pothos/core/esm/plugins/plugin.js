import { createContextCache } from '../utils/context-cache.js';
const runCache = new WeakMap();
export class BasePlugin {
    /**
   * Called for each type defined with the SchemaBuilder
   * @param  {PothosTypeConfig} typeConfig - Config object describing the added type
   * @return {PothosTypeConfig} Original or updated `typeConfig`
   */ onTypeConfig(typeConfig) {
        return typeConfig;
    }
    /**
   * Called for each field on an Object or Interface type
   * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field
   * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`
   */ onOutputFieldConfig(fieldConfig) {
        return fieldConfig;
    }
    /**
   * Called for each argument or field on an Input object defined in your schema
   * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field
   * @return {PothosInputFieldConfig} Original or updated `fieldConfig`
   */ onInputFieldConfig(fieldConfig) {
        return fieldConfig;
    }
    /**
   * Called for each Enum value defined in your schema
   * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value
   * @return {PothosEnumValueConfig} Original or updated `valueConfig`
   */ onEnumValueConfig(valueConfig) {
        return valueConfig;
    }
    /**
   * Called before builder.toSchema() schema is called
   */ beforeBuild() { }
    /**
   * Called after all fields and types have been built during `builder.toSchema()`
   * @param  {GraphQLSchema} schema - the generated schema
   * @return {PothosEnumValueConfig} Original or updated `schema`
   */ afterBuild(schema) {
        return schema;
    }
    /**
   * Called with the resolver for each field in the schema
   * @param  {GraphQLFieldResolver} resolve - the resolve function
   * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function
   * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field
   */ wrapResolve(resolver, fieldConfig) {
        return resolver;
    }
    /**
   * Called with the subscribe for each field on the Subscription type
   * @param  {GraphQLFieldResolver} subscribe - the subscribe function
   * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function
   * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field
   */ wrapSubscribe(subscribe, fieldConfig) {
        return subscribe;
    }
    /**
   * Called with the resolveType for each Interface or Union type
   * @param  {GraphQLTypeResolver} resolveType - the resolveType function
   * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type
   * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
   */ wrapResolveType(resolveType, typeConfig) {
        return resolveType;
    }
    /**
   * Called with the isTypeOf for each Object type
   * @param  {GraphQLTypeResolver} resolveType - the resolveType function
   * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type
   * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
   */ wrapIsTypeOf(isTypeOf, typeConfig) {
        return isTypeOf;
    }
    runUnique(key, cb) {
        if (!runCache.has(this.builder)) {
            runCache.set(this.builder, new Map());
        }
        if (!runCache.get(this.builder).has(key)) {
            const result = cb();
            runCache.get(this.builder).set(key, result);
            return result;
        }
        return runCache.get(this.builder).get(key);
    }
    /**
   * Creates a data object unique to the current request for use by this plugin
   * @param  {Types['Context']} context - the context object for the current request
   * @return {object} - The data object for the current request
   */ createRequestData(context) {
        throw new Error("createRequestData not implemented");
    }
    /**
   * Returns a data object for the current request.  requires `createRequestData` to be implemented
   * @param  {Types['Context']} context - the context object for the current request
   * @return {object} - The data object for the current request
   */ requestData(context) {
        return this.requestDataMap(context);
    }
    constructor(buildCache, name) {
        this.requestDataMap = createContextCache((ctx) => this.createRequestData(ctx));
        this.name = name;
        this.builder = buildCache.builder;
        this.buildCache = buildCache;
        this.options = buildCache.options;
    }
}
//# sourceMappingURL=plugin.js.map
