import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInt, GraphQLSchema, GraphQLString, lexicographicSortSchema } from 'graphql';
import BuildCache from './build-cache.js';
import ConfigStore from './config-store.js';
import { normalizeEnumValues, valuesFromEnum, verifyInterfaces, verifyRef } from './utils/index.js';
import { BaseTypeRef, EnumRef, ImplementableInputObjectRef, ImplementableInterfaceRef, ImplementableObjectRef, InputFieldBuilder, InputObjectRef, InterfaceFieldBuilder, InterfaceRef, MutationFieldBuilder, ObjectFieldBuilder, ObjectRef, QueryFieldBuilder, ScalarRef, SubscriptionFieldBuilder, UnionRef } from './index.js';
class SchemaBuilder {
    static registerPlugin(name, plugin) {
        if (!this.allowPluginReRegistration && this.plugins[name]) {
            throw new Error(`Received multiple implementations for plugin ${name}`);
        }
        this.plugins[name] = plugin;
    }
    objectType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _name;
        const name = typeof param === "string" ? param : (_name = options.name) !== null && _name !== void 0 ? _name : param.name;
        if (name === "Query" || name === "Mutation" || name === "Subscription") {
            throw new Error(`Invalid object name ${name} use .create${name}Type() instead`);
        }
        const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
        const config = {
            kind: "Object",
            graphqlKind: "Object",
            name,
            interfaces: [],
            description: options.description,
            extensions: options.extensions,
            isTypeOf: options.isTypeOf,
            pothosOptions: options
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(name, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, () => {
                const t = new ObjectFieldBuilder(name, this);
                return options.fields(t);
            });
        }
        return ref;
    }
    objectFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
        });
    }
    objectField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => ({
                [fieldName]: field(new ObjectFieldBuilder(name, this))
            }));
        });
    }
    queryType(options, fields) {
        const config = {
            kind: "Query",
            graphqlKind: "Object",
            name: "Query",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
        }
    }
    queryFields(fields) {
        this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    queryField(name, field) {
        this.configStore.addFields("Query", () => ({
            [name]: field(new QueryFieldBuilder(this))
        }));
    }
    mutationType(options, fields) {
        const config = {
            kind: "Mutation",
            graphqlKind: "Object",
            name: "Mutation",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
        }
    }
    mutationFields(fields) {
        this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    mutationField(name, field) {
        this.configStore.addFields("Mutation", () => ({
            [name]: field(new MutationFieldBuilder(this))
        }));
    }
    subscriptionType(options, fields) {
        const config = {
            kind: "Subscription",
            graphqlKind: "Object",
            name: "Subscription",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
        }
    }
    subscriptionFields(fields) {
        this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    subscriptionField(name, field) {
        this.configStore.addFields("Subscription", () => ({
            [name]: field(new SubscriptionFieldBuilder(this))
        }));
    }
    args(fields) {
        return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
    }
    interfaceType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _name;
        const name = typeof param === "string" ? param : (_name = options.name) !== null && _name !== void 0 ? _name : param.name;
        const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
        const typename = ref.name;
        const config = {
            kind: "Interface",
            graphqlKind: "Interface",
            name: typename,
            interfaces: [],
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions,
            resolveType: options.resolveType
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(typename, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(typename, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
        }
        return ref;
    }
    interfaceFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(name, this)));
        });
    }
    interfaceField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => ({
                [fieldName]: field(new InterfaceFieldBuilder(name, this))
            }));
        });
    }
    unionType(name, options) {
        const ref = new UnionRef(name);
        options.types.forEach((type) => {
            verifyRef(type);
        });
        const config = {
            kind: "Union",
            graphqlKind: "Union",
            name,
            types: options.types || [],
            description: options.description,
            resolveType: options.resolveType,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    enumType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : options.name;
        const ref = new EnumRef(name);
        const values = typeof param === "object" ? valuesFromEnum(param) : normalizeEnumValues(options.values);
        const config = {
            kind: "Enum",
            graphqlKind: "Enum",
            name,
            values,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        if (typeof param !== "string") {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            this.configStore.associateRefWithName(param, name);
        }
        return ref;
    }
    scalarType(name, options) {
        const ref = new ScalarRef(name);
        const config = {
            kind: "Scalar",
            graphqlKind: "Scalar",
            name,
            description: options.description,
            parseLiteral: options.parseLiteral,
            parseValue: options.parseValue,
            serialize: options.serialize,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    addScalarType(name, scalar, options) {
        const config = scalar.toConfig();
        return this.scalarType(name, {
            ...config,
            ...options,
            extensions: {
                ...config.extensions,
                ...options.extensions
            }
        });
    }
    inputType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : param.name;
        const ref = typeof param === "string" ? new InputObjectRef(name) : param;
        const config = {
            kind: "InputObject",
            graphqlKind: "InputObject",
            name,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
        return ref;
    }
    inputRef(name) {
        return new ImplementableInputObjectRef(this, name);
    }
    objectRef(name) {
        return new ImplementableObjectRef(this, name);
    }
    interfaceRef(name) {
        return new ImplementableInterfaceRef(this, name);
    }
    toSchema(options) {
        const { directives, extensions } = options;
        const scalars = [
            GraphQLID,
            GraphQLInt,
            GraphQLFloat,
            GraphQLString,
            GraphQLBoolean
        ];
        scalars.forEach((scalar) => {
            if (!this.configStore.hasConfig(scalar.name)) {
                this.addScalarType(scalar.name, scalar, {});
            }
        });
        const buildCache = new BuildCache(this, options);
        buildCache.plugin.beforeBuild();
        buildCache.buildAll();
        const builtTypes = [
            ...buildCache.types.values()
        ];
        const schema = new GraphQLSchema({
            query: buildCache.types.get("Query"),
            mutation: buildCache.types.get("Mutation"),
            subscription: buildCache.types.get("Subscription"),
            extensions,
            directives: directives,
            types: builtTypes
        });
        return lexicographicSortSchema(buildCache.plugin.afterBuild(schema));
    }
    constructor(options) {
        this.options = options;
        this.configStore = new ConfigStore();
        var _defaultFieldNullability;
        this.defaultFieldNullability = (_defaultFieldNullability = options.defaultFieldNullability) !== null && _defaultFieldNullability !== void 0 ? _defaultFieldNullability : false;
        var _defaultInputFieldRequiredness;
        this.defaultInputFieldRequiredness = (_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _defaultInputFieldRequiredness !== void 0 ? _defaultInputFieldRequiredness : false;
    }
}
SchemaBuilder.plugins = {};
SchemaBuilder.allowPluginReRegistration = false;
export { SchemaBuilder as default };
//# sourceMappingURL=builder.js.map
