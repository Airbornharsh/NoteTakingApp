/* eslint-disable @typescript-eslint/no-redundant-type-constituents */ /* eslint-disable node/no-callback-literal */ import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInt, GraphQLString } from 'graphql';
import { BaseTypeRef, BuiltinScalarRef, InputTypeRef, OutputTypeRef } from './index.js';
class ConfigStore {
    hasConfig(typeParam) {
        if (typeof typeParam === "string") {
            return this.typeConfigs.has(typeParam);
        }
        return this.refsToName.has(typeParam);
    }
    addInterfaces(typeName, interfaces) {
        if (typeof interfaces === "function" && this.pending) {
            if (!this.pendingInterfaces.has(typeName)) {
                this.pendingInterfaces.set(typeName, [
                    interfaces
                ]);
            }
            else {
                this.pendingInterfaces.get(typeName).push(interfaces);
            }
        }
        else {
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
                throw new Error(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.interfaces = [
                ...typeConfig.interfaces,
                ...typeof interfaces === "function" ? interfaces() : interfaces,
            ];
        }
    }
    addFieldRef(ref, // We need to be able to resolve the types kind before configuring the field
    typeParam, args, getConfig) {
        if (this.fieldRefs.has(ref)) {
            throw new Error(`FieldRef ${String(ref)} has already been added to config store`);
        }
        const typeRefOrName = Array.isArray(typeParam) ? typeParam[0] : typeParam;
        const argRefs = Object.keys(args).map((argName) => {
            const argRef = args[argName];
            argRef.fieldName = argName;
            argRef.argFor = ref;
            return argRef;
        });
        const checkArgs = () => {
            for (const arg of argRefs) {
                if (this.pendingFields.has(arg)) {
                    const unresolvedArgType = this.pendingFields.get(arg);
                    this.pendingFields.set(ref, unresolvedArgType);
                    this.onTypeConfig(unresolvedArgType, checkArgs);
                    return;
                }
            }
            this.pendingFields.delete(ref);
            this.fieldRefs.set(ref, getConfig);
        };
        if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
            checkArgs();
        }
        else {
            this.pendingFields.set(ref, typeRefOrName);
            this.onTypeConfig(typeRefOrName, () => {
                checkArgs();
            });
        }
    }
    createFieldConfig(ref, name, typeConfig, parentField, kind) {
        if (!this.fieldRefs.has(ref)) {
            if (this.pendingFields.has(ref)) {
                throw new Error(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
            }
            throw new Error(`Missing definition for for ${String(ref)}`);
        }
        const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
        if (kind && config.graphqlKind !== kind) {
            throw new TypeError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
        }
        return config;
    }
    associateRefWithName(ref, name) {
        if (!this.typeConfigs.has(name)) {
            throw new Error(`${name} has not been implemented yet`);
        }
        this.refsToName.set(ref, name);
        if (this.pendingRefResolutions.has(ref)) {
            const cbs = this.pendingRefResolutions.get(ref);
            this.pendingRefResolutions.delete(ref);
            cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
        }
    }
    addTypeConfig(config, ref) {
        const { name } = config;
        if (this.typeConfigs.has(name)) {
            throw new Error(`Duplicate typename: Another type with name ${name} already exists.`);
        }
        this.typeConfigs.set(config.name, config);
        if (ref) {
            this.associateRefWithName(ref, name);
        }
        if (this.pendingRefResolutions.has(name)) {
            const cbs = this.pendingRefResolutions.get(name);
            this.pendingRefResolutions.delete(name);
            cbs.forEach((cb) => void cb(config));
        }
    }
    getTypeConfig(ref, kind) {
        let config;
        if (typeof ref === "string") {
            if (!this.typeConfigs.has(ref)) {
                throw new Error(`Type ${String(ref)} has not been implemented`);
            }
            config = this.typeConfigs.get(ref);
        }
        else if (this.refsToName.has(ref)) {
            config = this.typeConfigs.get(this.refsToName.get(ref));
        }
        else {
            throw new Error(`Ref ${String(ref)} has not been implemented`);
        }
        if (kind && config.graphqlKind !== kind) {
            throw new TypeError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
        }
        return config;
    }
    getInputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
                throw new TypeError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
                    throw new TypeError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
                }
                const newRef = new InputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    getOutputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind === "InputObject") {
                throw new TypeError(`Expected ${ref.name} to be an output type but got ${ref.name}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind === "InputObject") {
                    throw new TypeError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
                }
                const newRef = new OutputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    onTypeConfig(ref, cb) {
        if (!ref) {
            throw new Error(`${String(ref)} is not a valid type ref`);
        }
        if (this.refsToName.has(ref)) {
            cb(this.getTypeConfig(ref));
        }
        else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
            cb(this.typeConfigs.get(ref));
        }
        else if (!this.pending) {
            throw new Error(`Ref ${String(ref)} has not been implemented`);
        }
        else if (this.pendingRefResolutions.has(ref)) {
            this.pendingRefResolutions.get(ref).push(cb);
        }
        else {
            this.pendingRefResolutions.set(ref, [
                cb
            ]);
        }
    }
    onFieldUse(ref, cb) {
        if (!this.fieldRefCallbacks.has(ref)) {
            this.fieldRefCallbacks.set(ref, []);
        }
        this.fieldRefCallbacks.get(ref).push(cb);
        if (this.fieldRefsToConfigs.has(ref)) {
            this.fieldRefsToConfigs.get(ref).forEach((config) => void cb(config));
        }
    }
    getFields(name, kind) {
        const typeConfig = this.getTypeConfig(name);
        if (!this.fields.has(name)) {
            this.fields.set(name, new Map());
        }
        const fields = this.fields.get(name);
        if (kind && typeConfig.graphqlKind !== kind) {
            throw new TypeError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
        }
        return fields;
    }
    prepareForBuild() {
        this.pending = false;
        const fns = this.addFieldFns;
        this.addFieldFns = [];
        fns.forEach((fn) => void fn());
        if (this.pendingRefResolutions.size > 0) {
            throw new Error(`Missing implementations for some references (${[
                ...this.pendingRefResolutions.keys()
            ].map((ref) => this.describeRef(ref)).join(", ")}).`);
        }
        for (const [typeName, interfacesFns] of this.pendingInterfaces) {
            for (const fn of interfacesFns) {
                this.addInterfaces(typeName, fn);
            }
        }
    }
    addFields(typeRef, fields) {
        if (this.pending) {
            this.addFieldFns.push(() => void this.addFields(typeRef, fields));
        }
        else {
            this.onTypeConfig(typeRef, (config) => {
                this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
            });
        }
    }
    getImplementers(ref) {
        const typeConfig = this.getTypeConfig(ref, "Interface");
        const implementers = [
            ...this.typeConfigs.values()
        ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
        return implementers;
    }
    describeRef(ref) {
        var ref1;
        if (typeof ref === "string") {
            return ref;
        }
        if (ref.toString !== ({}).toString) {
            return String(ref);
        }
        const usedBy = (ref1 = [
            ...this.pendingFields.entries()
        ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || ref1 === void 0 ? void 0 : ref1[0];
        if (usedBy) {
            return `<unnamed ref or enum: used by ${usedBy}>`;
        }
        return `<unnamed ref or enum>`;
    }
    buildFields(typeRef, fields) {
        Object.keys(fields).forEach((fieldName) => {
            const fieldRef = fields[fieldName];
            fieldRef.fieldName = fieldName;
            if (this.pendingFields.has(fieldRef)) {
                this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
                    this.buildField(typeRef, fieldRef, fieldName);
                });
            }
            else {
                this.buildField(typeRef, fieldRef, fieldName);
            }
        });
    }
    buildField(typeRef, field, fieldName) {
        const typeConfig = this.getTypeConfig(typeRef);
        const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
        const existingFields = this.getFields(typeConfig.name);
        if (existingFields.has(fieldName)) {
            throw new Error(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
        }
        if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
            throw new TypeError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
        }
        existingFields.set(fieldName, fieldConfig);
        if (!this.fieldRefsToConfigs.has(field)) {
            this.fieldRefsToConfigs.set(field, []);
        }
        this.fieldRefsToConfigs.get(field).push(fieldConfig);
        if (this.fieldRefCallbacks.has(field)) {
            this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
        }
    }
    constructor() {
        this.typeConfigs = new Map();
        this.fieldRefs = new WeakMap();
        this.fields = new Map();
        this.addFieldFns = [];
        this.refsToName = new Map();
        this.scalarsToRefs = new Map();
        this.fieldRefsToConfigs = new Map();
        this.pendingFields = new Map();
        this.pendingInterfaces = new Map();
        this.pendingRefResolutions = new Map();
        this.fieldRefCallbacks = new Map();
        this.pending = true;
        const scalars = [
            GraphQLID,
            GraphQLInt,
            GraphQLFloat,
            GraphQLString,
            GraphQLBoolean,
        ];
        scalars.forEach((scalar) => {
            const ref = new BuiltinScalarRef(scalar);
            this.scalarsToRefs.set(scalar.name, ref);
            this.refsToName.set(ref, scalar.name);
        });
    }
}
export { ConfigStore as default };
//# sourceMappingURL=config-store.js.map
