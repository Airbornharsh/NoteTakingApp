import { CompatibleTypes, FieldKind, FieldNullability, FieldOptionsFromKind, NormalizeArgs, SchemaTypes, TypeParam } from '../types';
import RootFieldBuilder from './root';
export default class FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends RootFieldBuilder<Types, ParentShape, Kind> {
    /**
     * Create a Boolean field from a boolean property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeBoolean<Name extends CompatibleTypes<Types, ParentShape, 'Boolean', Nullable>, ResolveReturnShape, Nullable extends FieldNullability<'Boolean'> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, 'Boolean', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<FieldNullability<"Boolean"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Boolean" extends infer T ? T extends "Boolean" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Boolean" extends infer T ? T extends "Boolean" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never : Nullable extends true ? ("Boolean" extends infer T ? T extends "Boolean" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Boolean" extends infer T ? T extends "Boolean" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never, Kind>;
    /**
     * Create a Float field from a numeric property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeFloat<Name extends CompatibleTypes<Types, ParentShape, 'Float', Nullable>, ResolveReturnShape, Nullable extends FieldNullability<'Float'> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, 'Float', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<FieldNullability<"Float"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Float" extends infer T ? T extends "Float" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Float" extends infer T ? T extends "Float" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never : Nullable extends true ? ("Float" extends infer T ? T extends "Float" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Float" extends infer T ? T extends "Float" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never, Kind>;
    /**
     * Create an ID field from a property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeID<Name extends CompatibleTypes<Types, ParentShape, 'ID', Nullable>, ResolveReturnShape, Nullable extends FieldNullability<'ID'> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, 'ID', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<FieldNullability<"ID"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("ID" extends infer T ? T extends "ID" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "ID" extends infer T ? T extends "ID" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never : Nullable extends true ? ("ID" extends infer T ? T extends "ID" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "ID" extends infer T ? T extends "ID" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never, Kind>;
    /**
     * Create an Int field from a numeric property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeInt<Name extends CompatibleTypes<Types, ParentShape, 'Int', Nullable>, ResolveReturnShape, Nullable extends FieldNullability<'Int'> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, 'Int', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'args' | 'resolve' | 'type'>
    ]>): import("..").FieldRef<FieldNullability<"Int"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Int" extends infer T ? T extends "Int" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Int" extends infer T ? T extends "Int" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never : Nullable extends true ? ("Int" extends infer T ? T extends "Int" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "Int" extends infer T ? T extends "Int" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never, Kind>;
    /**
     * Create a String field from a string property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeString<Name extends CompatibleTypes<Types, ParentShape, 'String', Nullable>, ResolveReturnShape, Nullable extends FieldNullability<'String'> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, 'String', Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<FieldNullability<"String"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("String" extends infer T ? T extends "String" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "String" extends infer T ? T extends "String" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never : Nullable extends true ? ("String" extends infer T ? T extends "String" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never) | null | undefined : "String" extends infer T ? T extends "String" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types").BaseEnum ? import("../types").ValuesFromEnum<T> : never : never : never, Kind>;
    /**
     * Create a Boolean list field from a boolean[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeBooleanList<Name extends CompatibleTypes<Types, ParentShape, ['Boolean'], Nullable>, ResolveReturnShape, Nullable extends FieldNullability<['Boolean']> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, [
            'Boolean'
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, ["Boolean"], Nullable>, Kind>;
    /**
     * Create a Float list field from a number[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeFloatList<Name extends CompatibleTypes<Types, ParentShape, ['Float'], Nullable>, ResolveReturnShape, Nullable extends FieldNullability<['Float']> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, [
            'Float'
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, ["Float"], Nullable>, Kind>;
    /**
     * Create an ID list field from an id[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeIDList<Name extends CompatibleTypes<Types, ParentShape, ['ID'], Nullable>, ResolveReturnShape, Nullable extends FieldNullability<['ID']> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, [
            'ID'
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, ["ID"], Nullable>, Kind>;
    /**
     * Create a Int list field from a number[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeIntList<Name extends CompatibleTypes<Types, ParentShape, ['Int'], Nullable>, ResolveReturnShape, Nullable extends FieldNullability<['Int']> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, [
            'Int'
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, ["Int"], Nullable>, Kind>;
    /**
     * Create a String list field from a string[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeStringList<Name extends CompatibleTypes<Types, ParentShape, ['String'], Nullable>, ResolveReturnShape, Nullable extends FieldNullability<['String']> = Types['DefaultFieldNullability']>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, [
            'String'
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve' | 'type'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, ["String"], Nullable>, Kind>;
    /**
     * Create a field that resolves to a property of the corresponding type on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    expose<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, ResolveReturnShape, Name extends CompatibleTypes<Types, ParentShape, Type, Nullable>>(...args: NormalizeArgs<[
        name: Name,
        options?: Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>, 'resolve'>
    ]>): import("..").FieldRef<import("../types").ShapeFromTypeParam<Types, Type, Nullable>, Kind>;
}
//# sourceMappingURL=builder.d.ts.map