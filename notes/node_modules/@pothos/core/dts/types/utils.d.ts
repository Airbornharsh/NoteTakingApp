export declare type MaybePromise<T> = Promise<T> | T;
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare type RequiredKeys<T extends object> = {
    [K in keyof T]: T[K] extends NonNullable<T[K]> ? K : never;
}[keyof T];
export declare type OptionalKeys<T extends object> = {
    [K in keyof T]: T[K] extends NonNullable<T[K]> ? never : K;
}[keyof T];
export declare type NonEmptyKeys<T extends object> = {
    [K in keyof T]: {} extends T[K] ? never : T[K] extends NonNullable<T[K]> ? K : never;
}[keyof T];
export declare type EmptyKeys<T extends object> = {
    [K in keyof T]: {} extends T[K] ? K : T[K] extends NonNullable<T[K]> ? never : K;
}[keyof T];
export declare type Normalize<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
export declare type NullableToOptional<T> = T extends object ? Normalize<{
    [K in OptionalKeys<T>]?: T[K];
} & {
    [K in RequiredKeys<T>]: T[K];
}> : T;
export declare type EmptyToOptional<T> = T extends object ? Normalize<{
    [K in EmptyKeys<T> | OptionalKeys<T>]?: T[K];
} & {
    [K in NonEmptyKeys<T>]: T[K];
}> : T;
export declare type NormalizeNullable<T> = undefined extends T ? T | null | undefined : null extends T ? T | null | undefined : T;
export declare type NormalizeNullableFields<T extends object> = {
    [K in OptionalKeys<T>]?: T[K] | null | undefined;
} & {
    [K in RequiredKeys<T>]: T[K];
};
export declare type RecursivelyNormalizeNullableFields<T> = T extends object[] ? Normalize<{
    [K in OptionalKeys<T[number]>]?: RecursivelyNormalizeNullableFields<T[number][K]> | null | undefined;
} & {
    [K in RequiredKeys<T[number]>]: RecursivelyNormalizeNullableFields<T[number][K]>;
}>[] : T extends unknown[] ? NormalizeNullable<T[number]>[] : T extends object ? Normalize<{
    [K in OptionalKeys<T>]?: RecursivelyNormalizeNullableFields<T[K]> | null | undefined;
} & {
    [K in RequiredKeys<T>]: RecursivelyNormalizeNullableFields<T[K]>;
}> : NormalizeNullable<T>;
export declare type RemoveNeverKeys<T extends {}> = {
    [K in keyof T as [T[K]] extends [never] ? never : K]: T[K];
};
export declare type Merge<T> = {
    [K in keyof T]: T[K];
};
export interface Path {
    prev: Path | undefined;
    key: number | string;
    typename: string | undefined;
}
export declare type LastIndex<T extends unknown[]> = T extends [unknown, ...infer U] ? U['length'] : 0;
export declare type NormalizeArgs<T extends unknown[]> = undefined extends T[LastIndex<T>] ? {} extends T[LastIndex<T>] ? T : {
    [K in keyof T]-?: NonNullable<T[K]>;
} : T;
export declare type IsStrictMode = undefined extends {
    t: 1;
}['t'] ? false : true;
//# sourceMappingURL=utils.d.ts.map