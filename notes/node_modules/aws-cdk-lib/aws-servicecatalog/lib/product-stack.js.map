{
  "version": 3,
  "sources": ["product-stack.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as cdk from '../../core';\nimport { ProductStackSynthesizer } from './private/product-stack-synthesizer';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * A Service Catalog product stack, which is similar in form to a Cloudformation nested stack.\n * You can add the resources to this stack that you want to define for your service catalog product.\n *\n * This stack will not be treated as an independent deployment\n * artifact (won't be listed in \"cdk list\" or deployable through \"cdk deploy\"),\n * but rather only synthesized as a template and uploaded as an asset to S3.\n *\n */\nexport class ProductStack extends cdk.Stack {\n  public readonly templateFile: string;\n  private _templateUrl?: string;\n  private _parentStack: cdk.Stack;\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id, {\n      synthesizer: new ProductStackSynthesizer(),\n    });\n\n    this._parentStack = findParentStack(scope);\n\n    // this is the file name of the synthesized template file within the cloud assembly\n    this.templateFile = `${cdk.Names.uniqueId(this)}.product.template.json`;\n  }\n\n  /**\n   * Fetch the template URL.\n   *\n   * @internal\n   */\n  public _getTemplateUrl(): string {\n    return cdk.Lazy.uncachedString({ produce: () => this._templateUrl });\n  }\n\n  /**\n   * Synthesize the product stack template, overrides the `super` class method.\n   *\n   * Defines an asset at the parent stack which represents the template of this\n   * product stack.\n   *\n   * @internal\n   */\n  public _synthesizeTemplate(session: cdk.ISynthesisSession): void {\n    const cfn = JSON.stringify(this._toCloudFormation(), undefined, 2);\n    const templateHash = crypto.createHash('sha256').update(cfn).digest('hex');\n\n    this._templateUrl = this._parentStack.synthesizer.addFileAsset({\n      packaging: cdk.FileAssetPackaging.FILE,\n      sourceHash: templateHash,\n      fileName: this.templateFile,\n    }).httpUrl;\n\n    fs.writeFileSync(path.join(session.assembly.outdir, this.templateFile), cfn);\n  }\n}\n\n/**\n * Validates the scope for a product stack, which must be defined within the scope of another `Stack`.\n */\nfunction findParentStack(scope: Construct): cdk.Stack {\n  try {\n    const parentStack = cdk.Stack.of(scope);\n    return parentStack as cdk.Stack;\n  } catch (e) {\n    throw new Error('Product stacks must be defined within scope of another non-product stack');\n  }\n}\n"],
  "mappings": "wJAAA,OAAA,QAAA,QAAA,EACA,GAAA,QAAA,IAAA,EACA,KAAA,QAAA,MAAA,EACA,IAAA,QAAA,YAAA,EACA,4BAAA,QAAA,qCAAA,EAeA,MAAa,oBAAqB,KAAI,KAAK,CAKzC,YAAY,MAAkB,GAAU,CACtC,MAAM,MAAO,GAAI,CACf,YAAa,GAAI,6BAAA,wBAClB,EAED,KAAK,aAAe,gBAAgB,KAAK,EAGzC,KAAK,aAAe,GAAG,IAAI,MAAM,SAAS,IAAI,0BAQzC,iBAAe,CACpB,MAAO,KAAI,KAAK,eAAe,CAAE,QAAS,IAAM,KAAK,YAAY,CAAE,EAW9D,oBAAoB,QAA8B,CACvD,KAAM,KAAM,KAAK,UAAU,KAAK,kBAAiB,EAAI,OAAW,CAAC,EAC3D,aAAe,OAAO,WAAW,QAAQ,EAAE,OAAO,GAAG,EAAE,OAAO,KAAK,EAEzE,KAAK,aAAe,KAAK,aAAa,YAAY,aAAa,CAC7D,UAAW,IAAI,mBAAmB,KAClC,WAAY,aACZ,SAAU,KAAK,aAChB,EAAE,QAEH,GAAG,cAAc,KAAK,KAAK,QAAQ,SAAS,OAAQ,KAAK,YAAY,EAAG,GAAG,GA3C/E,QAAA,aAAA,yHAkDA,yBAAyB,MAAgB,CACvC,GAAI,CAEF,MADoB,KAAI,MAAM,GAAG,KAAK,OAEtC,CACA,KAAM,IAAI,OAAM,0EAA0E,EAE9F",
  "names": []
}
